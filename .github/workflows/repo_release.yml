name: repo release

on:
  release:
    types:
      - created
  workflow_dispatch: {}

permissions:
  contents: write

env:
  GITHUB_TOKEN: ${{ secrets.GIT_TOKEN  }}

jobs:
  release-kine:
    runs-on: ubuntu-latest
    timeout-minutes: 2
    steps:
    - uses: actions/checkout@v4
    - name: Render manifests
      run: make kine-release
      env:
        TAG: ${{ github.ref_name }}
    - name: Create release
      if: ${{ !startsWith(github.ref, 'refs/heads/dev-') }}
      uses: mhmxs/milestone-release-action@main
      with:
        milestone-title: ${{ github.ref_name }}
        pre-body: |
            # Kine

            ## What is this?

            Normally, Kubernetes uses a database called etcd. Kine (Kine is not etcd) is a tool that allows Kubernetes to use other databases (like SQLite or PostgreSQL) instead.

            This specific version of Kine is special because it handles filtering and garbage-collection directly at the database level, which can make your cluster much faster and more efficient.

            ## Installation: The vCluster Method

            The easiest way to use this setup is inside a vCluster (a virtual cluster running inside your real cluster). This keeps everything bundled together.

            - Step A: Bring your own cluster

            - Step B: Deploy the vCluster

            Run these commands to create your virtual cluster using a pre-configured SQLite setup:

            ```bash
            # This creates the virtual cluster resources
            kubectl apply -f https://github.com/HariKube/kine/releases/download/release-v0.14.6/vcluster-kine-sqlite-release-v0.14.6.yaml

            # Wait for readiness
            kubectl wait -n kine --for=jsonpath='{.status.readyReplicas}'=1 statefulset/kine --timeout=5m

            # This connects your local terminal to the new virtual cluster
            vcluster connect kine
            ```

            > ðŸ”“ vCluster simplifies the operational workflow by automatically updating your local environment. For more details how to disable this behaviour, or how to get config by service account for example please wisit the official docs` [Access and expose vCluster](https://www.vcluster.com/docs/vcluster/manage/accessing-vcluster) section.

            > ðŸ”“ For service access from host, the vCluster setup keeps things simple: Create your ServiceAccount, create a secret annotated with `kubernetes.io/service-account.name` (example below), and vCluster will sync the secret to the host cluster.

            ```yaml
            apiVersion: v1
            kind: Secret
            metadata:
              name: remote-your-service-account-name
              annotations:
                kubernetes.io/service-account.name: "your-service-account-name"
            type: kubernetes.io/service-account-token
            ```

            On the host cluster, you can fetch the connection details.

            ```bash
            KUBE_API_URL=kine.kine.svc.cluster.local
            TOKEN=$(kubectl get secret -n kine remote-your-service-account-name-x-default-x-kine -o jsonpath='{.data.token}' | base64 -d)
            CA_CERT=$(kubectl get secret -n kine remote-your-service-account-name-x-default-x-kine -o jsonpath='{.data.ca\.crt}' | base64 -d)
            ```

            - Step C: Enjoy

            ## Storage-side Garbage-Collection

            Garbage-collection (GC) keeps your database from getting bloated. This version of Kine looks for a specific label on your resources: `skip-controller-manager-metadata-caching="true"`. Otherwise, Kubernetes Controller Manager will keep records in memory, which should kill performance.

            The "Auto-Label" Trick

            Instead of adding that label to every single pod or service by hand, you can use a `MutatingAdmissionPolicy`. Think of this as an automated "bouncer" that stamps every new resource with the required label as it enters the cluster.

            ```yaml
            apiVersion: admissionregistration.k8s.io/v1beta1
            kind: MutatingAdmissionPolicy
            metadata:
              name: "skip-controller-manager-metadata-caching"
            spec:
              matchConstraints:
                resourceRules:
                - apiGroups:   ["*"]
                  apiVersions: ["*"]
                  operations:  ["CREATE"]
                  resources:   ["*"]
              matchConditions:
                - name: label-does-not-exist
                  expression: >
                      !has(object.metadata.labels) ||
                      !('skip-controller-manager-metadata-caching' in object.metadata.labels)
              failurePolicy: Fail
              reinvocationPolicy: IfNeeded
              mutations:
                - patchType: JSONPatch
                  jsonPatch:
                    expression: >
                      has(object.metadata.labels)
                      ? [
                          JSONPatch{
                            op: "add",
                            path: "/metadata/labels/skip-controller-manager-metadata-caching",
                            value: "true"
                          }
                        ]
                      : [
                          JSONPatch{
                            op: "add",
                            path: "/metadata/labels",
                            value: {}
                          },
                          JSONPatch{
                            op: "add",
                            path: "/metadata/labels/skip-controller-manager-metadata-caching",
                            value: "true"
                          }
                        ]
            ---
            apiVersion: admissionregistration.k8s.io/v1beta1
            kind: MutatingAdmissionPolicyBinding
            metadata:
              name: "skip-controller-manager-metadata-caching"
            spec:
              policyName: "skip-controller-manager-metadata-caching"
              matchResources:
                resourceRules:
                - apiGroups:   ["*"]
                  apiVersions: ["*"]
                  operations:  ["CREATE"]
                  resources:   ["*"]
            ```

            Applying the YAML provided in your notes will ensure that everything in your cluster is eligible for storage-side garbage-collection without any manual work.

            ## Important Requirement

            To use these features to their full potential, you cannot use "standard" Kubernetes. You must use the patched images provided by us These patches allow the Kubernetes API to understand the special storage instructions Kine is waiting for.

            - [Kubernetes Patches](https://github.com/HariKube/kubernetes-patches)
            - [Patched Images](https://quay.io/repository/harikube/kubernetes?tab=tags&tag=latest)

            ## Release Notes

        draft: true
        prerelease: ${{ startsWith(github.ref, 'refs/heads/rc-') || startsWith(github.ref, 'refs/heads/beta-') || startsWith(github.ref, 'refs/heads/alpha-') }}
        files: package/vcluster-kine-sqlite-${{ github.ref_name }}.yaml
  